<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>IFC Space Graph Viewer</title>
  <link rel="icon" type="image/png" href="/static/dtu_logo.png" />

  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>

  <style>
    body { margin:0; background:white; color:black; font-family:Arial; }
    #3d-graph { position:fixed; inset:0; top:170px; }
    .scene-nav-info { display: none !important; }

    #no-graph-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #666;
      font-size: 18px;
      z-index: 1;
      pointer-events: none;
    }

    #no-graph-message.hidden {
      display: none;
    }

    #banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 150px;
      background-color: #990000;
      color: white;
      z-index: 10000;
      padding: 15px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    #banner-content {
      flex: 1;
    }

    #banner-logo {
      position: absolute;
      top: 15px;
      right: 20px;
      height: 70px;
      max-width: 140px;
      object-fit: contain;
    }

    #banner h1 {
      margin: 0 0 8px 0;
      font-size: 24px;
      font-weight: bold;
    }

    #banner p {
      margin: 0 0 12px 0;
      font-size: 14px;
      opacity: 0.95;
    }

    #upload-section {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 0;
      margin-top: 22px;
    }

    #fileInput {
      flex: 1;
      padding: 8px;
      font-size: 14px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.1);
      color: white;
    }

    #fileInput::file-selector-button {
      padding: 6px 12px;
      margin-right: 10px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.2);
      color: white;
      cursor: pointer;
    }

    #generateBtn {
      padding: 8px 20px;
      font-size: 14px;
      font-weight: bold;
      border-radius: 6px;
      border: none;
      background: white;
      color: #990000;
      cursor: pointer;
      transition: background 0.2s;
    }

    #generateBtn:hover:not(:disabled) {
      background: #f0f0f0;
    }

    #generateBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    #statusMessage {
      margin-top: 8px;
      font-size: 13px;
      min-height: 18px;
      line-height: 1.3;
    }

    #controls {
      position: absolute;
      top: 190px;
      left: 20px;
      background: rgba(255,255,255,0.9);
      padding: 15px 18px;
      border-radius: 10px;
      width: 260px;
      font-size: 14px;
      z-index: 9999;
      color:black;
      box-shadow: 0 6px 18px rgba(0,0,0,0.15);
      display: none;
    }

    #controls.visible {
      display: block;
    }

    #controls select, #controls button {
      width: 100%;
      padding: 6px;
      margin-top: 8px;
      font-size: 14px;
      border-radius: 6px;
      border: 1px solid rgba(0,0,0,0.2);
      background: white;
      color: black;
    }

    #instructions {
      position: fixed;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 13px;
      color: #333333;
      pointer-events: none;
    }
  </style>
</head>

<body>

<div id="banner">
  <div id="banner-content">
    <h1>IFC Space Graph Viewer</h1>
    <p>Upload your 4x3 IFC file from your model and press the Generate Graph button.</p>
    <div id="upload-section">
      <input type="file" id="fileInput" accept=".ifc" />
      <button id="generateBtn">Generate Graph</button>
    </div>
    <div id="statusMessage"></div>
  </div>
  <img id="banner-logo" src="/static/dtu_white.png" alt="DTU Logo" />
</div>

<div id="controls">
  <strong style="font-size:16px">Graph Controls</strong><br><br>

  Highlight space & adjacencies<br>
  <select id="roomSelect">
    <option value="__all__">All</option>
  </select>

  <br><br>

  Filter by ISO grade <br>
  <select id="gradeSelect">
    <option value="__all__">All</option>
    <option value="7">ISO 7 / Grade C</option>
    <option value="8">ISO 8 / Grade D</option>
    <option value="0">Unclassified</option>
    <option value="LEVEL">Level</option>
  </select>

  <br><br>

  Filter by level <br>
  <select id="levelSelect">
    <option value="__all__">All levels</option>
  </select>

  <button id="resetGraphBtn" style="margin-top:12px;">
    Show Full Graph
  </button>
</div>

<div id="3d-graph"></div>

<div id="no-graph-message">
  <p>No graph loaded. Please upload an IFC file and click "Generate Graph" to begin.</p>
</div>

<div id="instructions">
  Left-click: rotate &nbsp; | &nbsp; Mouse-wheel: zoom &nbsp; | &nbsp; Right-click: pan
</div>

<script type="module">
import SpriteText from "https://esm.sh/three-spritetext";

let fullData = null;
let currentData = null;

function getIsoRaw(node) {
  const v = (node.iso ?? node.d4 ?? "").toString().trim();
  return v === "" ? "0" : v;
}

function isoClassLabel(iso) {
  return iso === "0" ? "Unclassified" : `ISO ${iso}`;
}

function getNodeColor(node) {
  // Non-space nodes
  if (node.ifc_type !== "IfcSpace") return "#b180ff";

  switch (getIsoRaw(node)) {
    case "5": return "#4a84ff";
    case "7": return "#8bd46b";
    case "8": return "#ffb36b";
    case "0": return "#d0d0d0";
    default:  return "#d0d0d0";
  }
}

function formatNodeHover(node) {
  const name = node.name || node.id;

  let html = `<b>${name}</b>`;
  if (node.ifc_type === "IfcSpace") {
    html += `<br>ISO class: ${isoClassLabel(getIsoRaw(node))}`;
    if (node.area) html += `<br>Area: ${node.area} m²`;
    if (node.volume) html += `<br>Volume: ${node.volume} m³`;
  }
  return html;
}

function baseLinkColor(link) {
  return link.type === "contains"
    ? "rgba(0,150,255,0.55)"
    : "rgba(0,0,0,0.18)";
}

const Graph = ForceGraph3D()(document.getElementById("3d-graph"))
  .backgroundColor("#ffffff")
  .nodeColor(n => getNodeColor(n))
  .nodeLabel(n => formatNodeHover(n))
  .nodeVal(() => 1)
  .nodeRelSize(3.2)

  .nodeThreeObject(node => {
    const label = new SpriteText(node.name || node.id);
    label.color = "black";
    label.textHeight = node.ifc_type === "IfcSpace" ? 2.1 : 1.6;
    label.position.y = 4.0;
    return label;
  })
  .nodeThreeObjectExtend(true)

  .linkWidth(0.6)
  .linkOpacity(0.25)
  .linkColor(l => baseLinkColor(l));

/* Hover: connected edges turn yellow */
Graph.onNodeHover(node => {
  Graph.linkColor(l => {
    const s = typeof l.source === "object" ? l.source.id : l.source;
    const t = typeof l.target === "object" ? l.target.id : l.target;
    if (node && (s === node.id || t === node.id)) return "gold";
    return baseLinkColor(l);
  });
});

Graph.onNodeClick(node => {
  const distance = 55;
  const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
  Graph.cameraPosition(
    { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio },
    node,
    1500
  );
});

function resetGraph() {
  currentData = fullData;
  Graph.graphData(fullData);
  document.getElementById("roomSelect").value = "__all__";
  document.getElementById("gradeSelect").value = "__all__";
  const lvl = document.getElementById("levelSelect");
  if (lvl) lvl.value = "__all__";
}

/* Room filter */
function highlightRoom(roomId) {
  if (roomId === "__all__") return resetGraph();

  const keep = new Set([roomId]);

  fullData.links.forEach(l => {
    const s = typeof l.source === "object" ? l.source.id : l.source;
    const t = typeof l.target === "object" ? l.target.id : l.target;
    if (s === roomId) keep.add(t);
    if (t === roomId) keep.add(s);
  });

  const nodes = fullData.nodes.filter(n => keep.has(n.id));
  const links = fullData.links.filter(l => {
    const s = typeof l.source === "object" ? l.source.id : l.source;
    const t = typeof l.target === "object" ? l.target.id : l.target;
    return keep.has(s) && keep.has(t);
  });

  currentData = { nodes, links };
  Graph.graphData(currentData);
}

/* ISO filter */
function filterByGrade(grade) {
  if (grade === "__all__") return resetGraph();

  const nodes = fullData.nodes.filter(n => {
    if (grade === "LEVEL") return n.ifc_type !== "IfcSpace";
    if (n.ifc_type !== "IfcSpace") return false;
    return getIsoRaw(n) === grade;
  });

  const ids = new Set(nodes.map(n => n.id));

  const links = fullData.links.filter(l => {
    const s = typeof l.source === "object" ? l.source.id : l.source;
    const t = typeof l.target === "object" ? l.target.id : l.target;
    return ids.has(s) && ids.has(t);
  });

  currentData = { nodes, links };
  Graph.graphData(currentData);
}

/* Level filter */
function filterByLevel(levelId) {
  if (levelId === "__all__") return resetGraph();

  const levelsById = (fullData._levelsById) || {};
  const levelName = levelsById[levelId] || null;
  // Build a set of nodes that match the level (by id, storey, level, or name)
  const keep = new Set();

  fullData.nodes.forEach(n => {
    if (n.ifc_type === 'IfcBuildingStorey' && n.id === levelId) keep.add(n.id);
    if (n.storey && n.storey === levelId) keep.add(n.id);
    if (n.level && (n.level === levelId || n.level === levelName)) keep.add(n.id);

    for (const k in n) {
      if (!Object.prototype.hasOwnProperty.call(n, k)) continue;
      if (n[k] === levelId) keep.add(n.id);
    }

    if (levelName && n.name && n.name.toLowerCase().includes(levelName.toLowerCase())) keep.add(n.id);
  });

  if (fullData.nodes.find(n => n.id === levelId)) keep.add(levelId);

  fullData.links.forEach(l => {
    const s = typeof l.source === "object" ? l.source.id : l.source;
    const t = typeof l.target === "object" ? l.target.id : l.target;
    if (keep.has(s)) keep.add(t);
    if (keep.has(t)) keep.add(s);
  });

  const nodes = fullData.nodes.filter(n => keep.has(n.id));
  const links = fullData.links.filter(l => {
    const s = typeof l.source === "object" ? l.source.id : l.source;
    const t = typeof l.target === "object" ? l.target.id : l.target;
    return keep.has(s) && keep.has(t);
  });

  currentData = { nodes, links };
  Graph.graphData(currentData);
}


async function loadGraphML(url) {
  if (!url) {
    console.error("No URL provided to loadGraphML");
    return;
  }

  const noGraphMsg = document.getElementById("no-graph-message");
  if (noGraphMsg) {
    noGraphMsg.classList.add("hidden");
  }

  const text = await (await fetch(url)).text();
  const xml = new DOMParser().parseFromString(text, "application/xml");

  const keyMap = {};
  [...xml.getElementsByTagName("key")].forEach(k => {
    const id = k.getAttribute("id");
    const attrName = k.getAttribute("attr.name");
    if (id) keyMap[id] = attrName || id;
  });

  let nodes = [...xml.getElementsByTagName("node")].map(n => {
    const id = n.getAttribute("id");
    const obj = { id };

    [...n.getElementsByTagName("data")].forEach(d => {
      const keyId = d.getAttribute("key");
      const keyName = keyMap[keyId] || keyId;
      const val = d.textContent.trim();

      obj[keyName] = val; // e.g. obj.iso
      obj[keyId] = val;   // e.g. obj.d4
    });

    return obj;
  });

  let links = [...xml.getElementsByTagName("edge")].map(e => {
    const link = { source: e.getAttribute("source"), target: e.getAttribute("target") };

    [...e.getElementsByTagName("data")].forEach(d => {
      const keyId = d.getAttribute("key");
      const keyName = keyMap[keyId] || keyId;
      const val = d.textContent.trim();
      link[keyName] = val;
      link[keyId] = val;
    });

    return link;
  });

  nodes = nodes.filter(n => (n.name || "").trim().toLowerCase() !== "level 2");

  fullData = { nodes, links };
  currentData = fullData;

  Graph.graphData(fullData);

  const roomSelect = document.getElementById("roomSelect");
  roomSelect.innerHTML = `<option value="__all__">All</option>`;

  const spaceNodes = nodes
    .filter(n => n.ifc_type === "IfcSpace")
    .sort((a, b) => (a.name || "").localeCompare(b.name || ""));

  spaceNodes.forEach(n => {
    const opt = document.createElement("option");
    opt.value = n.id;
    opt.textContent = n.name || n.id;
    roomSelect.appendChild(opt);
  });

  roomSelect.onchange = e => highlightRoom(e.target.value);
  document.getElementById("gradeSelect").onchange = e => filterByGrade(e.target.value);

  const levelSelect = document.getElementById("levelSelect");
  if (levelSelect) {
    levelSelect.innerHTML = `<option value="__all__">All levels</option>`;

    const levelNodes = nodes.filter(n => n.ifc_type === 'IfcBuildingStorey' || (n.name && /level/i.test(n.name)));
    const levelsById = {};
    levelNodes.forEach(l => {
      if (levelsById[l.id]) return; // skip duplicates
      levelsById[l.id] = l.name || l.id;
    });

    const sortedLevelIds = Object.keys(levelsById).sort((a, b) => (levelsById[a] || '').localeCompare(levelsById[b] || ''));
    sortedLevelIds.forEach(id => {
      const opt = document.createElement('option');
      opt.value = id;
      opt.textContent = levelsById[id];
      levelSelect.appendChild(opt);
    });

    fullData._levelsById = levelsById;

    levelSelect.onchange = e => filterByLevel(e.target.value);
  }

  const controls = document.getElementById("controls");
  if (controls) {
    controls.classList.add("visible");
  }
}

async function generateGraph() {
  console.log("generateGraph called");
  const fileInput = document.getElementById("fileInput");
  const generateBtn = document.getElementById("generateBtn");
  const statusMessage = document.getElementById("statusMessage");

  if (!fileInput || !generateBtn || !statusMessage) {
    console.error("Required elements not found");
    return;
  }

  if (!fileInput.files || fileInput.files.length === 0) {
    statusMessage.textContent = "Please select an IFC file first.";
    statusMessage.style.color = "#ffcccc";
    return;
  }

  const file = fileInput.files[0];
  if (!file.name.toLowerCase().endsWith('.ifc')) {
    statusMessage.textContent = "Please select a valid .ifc file.";
    statusMessage.style.color = "#ffcccc";
    return;
  }

  generateBtn.disabled = true;
  statusMessage.textContent = "Uploading and processing file...";
  statusMessage.style.color = "white";

  try {
    const formData = new FormData();
    formData.append('file', file);

    console.log("Sending file to server...");
    const response = await fetch('/upload', {
      method: 'POST',
      body: formData
    });

    console.log("Response status:", response.status);
    
    if (!response.ok && response.status === 404) {
      throw new Error('Server not found. Please make sure the Flask server is running (python app.py)');
    }

    const result = await response.json();
    console.log("Server response:", result);

    if (!response.ok) {
      throw new Error(result.error || 'Failed to generate graph');
    }

    statusMessage.textContent = "Graph generated successfully! Loading...";
    statusMessage.style.color = "#90EE90";

    setTimeout(() => {
      loadGraphML('data/facility.graphml?t=' + Date.now()).then(() => {
        statusMessage.textContent = "Graph loaded successfully!";
      }).catch((error) => {
        statusMessage.textContent = "Error loading graph: " + error.message;
        statusMessage.style.color = "#ffcccc";
        console.error('Error loading graph:', error);
      });
    }, 500);

  } catch (error) {
    statusMessage.textContent = "Error: " + error.message;
    statusMessage.style.color = "#ffcccc";
    console.error('Error generating graph:', error);
  } finally {
    generateBtn.disabled = false;
  }
}

const generateBtn = document.getElementById("generateBtn");
if (generateBtn) {
  console.log("Event listener attached to generate button");
  generateBtn.addEventListener('click', generateGraph);
} else {
  console.error("Generate button not found!");
}

const resetGraphBtn = document.getElementById("resetGraphBtn");
if (resetGraphBtn) {
  console.log("Event listener attached to reset graph button");
  resetGraphBtn.addEventListener('click', resetGraph);
} else {
  console.error("Reset graph button not found!");
}

</script>

</body>
</html>
